# Headless Philosophy

## What is Headless?

**Headless components separate logic from presentation.**

Instead of providing a complete UI component with predefined styles, a headless library gives you the **logic, state management, and behavior** - leaving the visual presentation entirely up to you.

## The Problem with Traditional Calendar Libraries

Traditional calendar libraries come with built-in UI:

```tsx
// Traditional approach - UI is bundled
import Calendar from 'some-calendar-lib';

<Calendar
  theme="dark"           // Limited theme options
  primaryColor="blue"    // Restricted customization
  borderRadius="8px"     // Can't match your design system
/>
```

**Problems:**
- ğŸ¨ **Design constraints** - Can't fully match your design system
- ğŸ“¦ **Bundle bloat** - Shipping CSS you don't use
- ğŸ”§ **Override hell** - Fighting with `!important` to customize
- ğŸš« **Framework lock-in** - Doesn't work with your CSS solution

## The Headless Approach

With `@h6s/calendar`, you get pure logic:

```tsx
// Headless approach - you control everything
import { useCalendar } from '@h6s/calendar';

const { headers, body, navigation } = useCalendar();

// Build YOUR calendar with YOUR styling
<YourCustomCalendar
  data={body}
  onNavigate={navigation}
  className={yourStyles}
/>
```

**Benefits:**
- âœ… **Complete design freedom** - Match any design system perfectly
- âœ… **Lightweight** - No CSS bundle, just logic
- âœ… **Flexible** - Use any styling solution (Tailwind, CSS Modules, styled-components, etc.)
- âœ… **Framework agnostic** - Works anywhere React works

## Separation of Concerns

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Your Application            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Presentation Layer (Your Control)  â”‚
â”‚  â€¢ Styling (Tailwind/CSS/etc)       â”‚
â”‚  â€¢ Markup structure                 â”‚
â”‚  â€¢ Visual design                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Logic Layer (@h6s/calendar)        â”‚
â”‚  â€¢ Date calculations                â”‚
â”‚  â€¢ State management                 â”‚
â”‚  â€¢ Navigation logic                 â”‚
â”‚  â€¢ Calendar data structure          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The logic layer is stable and well-tested. The presentation layer is entirely yours to customize.

## Real-World Example

Let's see how the same hook works with different styling solutions:

### With Tailwind CSS

```tsx
import { useCalendar } from '@h6s/calendar';

function TailwindCalendar() {
  const { body } = useCalendar();

  return (
    <div className="bg-white rounded-lg shadow-md p-4">
      {body.value.map(week => (
        <div className="flex gap-2">
          {week.value.map(day => (
            <button className="w-10 h-10 rounded-full hover:bg-blue-100">
              {format(day.value, 'd')}
            </button>
          ))}
        </div>
      ))}
    </div>
  );
}
```

### With CSS Modules

```tsx
import { useCalendar } from '@h6s/calendar';
import styles from './Calendar.module.css';

function CSSModulesCalendar() {
  const { body } = useCalendar();

  return (
    <div className={styles.calendar}>
      {body.value.map(week => (
        <div className={styles.week}>
          {week.value.map(day => (
            <button className={styles.day}>
              {format(day.value, 'd')}
            </button>
          ))}
        </div>
      ))}
    </div>
  );
}
```

### With styled-components

```tsx
import { useCalendar } from '@h6s/calendar';
import styled from 'styled-components';

const CalendarContainer = styled.div`
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  padding: 16px;
`;

const Day = styled.button`
  width: 40px;
  height: 40px;
  border-radius: 50%;
  &:hover {
    background: #e3f2fd;
  }
`;

function StyledCalendar() {
  const { body } = useCalendar();

  return (
    <CalendarContainer>
      {/* Same logic, different styles */}
    </CalendarContainer>
  );
}
```

## Same Logic, Any Design

The power of headless is that **the calendar logic never changes**, but you can create completely different visual experiences:

- ğŸ“± Mobile-first calendar
- ğŸ¨ Neumorphic design
- ğŸŒ™ Dark mode friendly
- â™¿ Accessibility-focused
- ğŸ¢ Corporate design system
- ğŸ® Gaming UI theme

All using the same `useCalendar()` hook.

## When to Use Headless?

**Use headless when:**
- âœ… You have a design system to match
- âœ… You need full control over styling
- âœ… You want to minimize bundle size
- âœ… You're building a design system yourself

**Consider traditional components when:**
- âŒ You need a quick prototype with default styles
- âŒ You don't care about visual customization
- âŒ You want an out-of-the-box solution

## Philosophy in Action

See our [Examples](/docs/examples) to see how the same `useCalendar` hook powers completely different calendar designs:

- DatePicker with popover
- DateRangePicker with dual calendars
- Standalone date calendars
- All with Tailwind, Vanilla CSS, and Bootstrap variants

Each example uses **the exact same hook**, just with different presentation layers.

---

**Next:** Learn how to use the [API Reference](/api-docs/api/use-calendar) to build your own calendar.
